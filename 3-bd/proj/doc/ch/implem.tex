% !TEX root = ../story.tex

\chapter{Implementare în PostgreSQL}

\section{Instalare și configurare inițială}
\index{instalare}
\index{configurare}

Pentru implementare, vom folosi sistemul de baze de date
\href{https://www.postgresql.org/}{PostgreSQL}, disponibil gratuit și
open source.

Implementarea se va face pe laptopul personal, folosind:
\begin{itemize}
\item OS: Manjaro Linux i3;
\item Emacs 26 pentru editare text și comenzi shell;
\item \texttt{st} pentru comenzi avansate de terminal, dacă este necesar.
\end{itemize}

Programul se instalează folosind managerul de pachete din Manjaro,
cu comanda:
{
  \small
\begin{verbatim}
$ sudo pacman -S postgresql
\end{verbatim}
}

După instalare, putem consulta consulta detaliile de pe pagina
\href{https://wiki.archlinux.org/index.php/PostgreSQL\#Create\_your\_first\_database/user}{ArchWiki}.

Pe scurt, PostgreSQL creează automat un utilizator cu numele \texttt{postgres},
care este proprietarul implicit al bazelor de date. Astfel, pentru a lansa
aplicația și a face modificări, trebuie să ne identificăm ca utilizatorul \texttt{postgres},
cu una dintre comenzile:

{
  \small
\begin{verbatim}
$ sudo -iu postgres
$ su -l postgres
\end{verbatim}
}

Inițializarea cluster-ului de baze de date, unde se vor crea bazele și tabelele
se face în calitatea de utilizator \texttt{postgres}, de exemplu, în locația
implicită, cu comanda:

{
  \small
\begin{verbatim}
[postgres]$ initdb -D /var/lib/postgres/data

# pentru a forța utilizarea limbii engleze și a codării UTF-8, folosim comanda
[postgres]$ initdb --locale=en_US.UTF-8 -E UTF8 -D /var/lib/postgres/data

# ... output ...
# finalizat cu ... ok
\end{verbatim}
}

Folosind \texttt{systemd}, trebuie să activăm și să pornim daemon-ul \texttt{postgresql},
cu comenzile:
{
  \small
\begin{verbatim}
$ sudo systemctl enable postgresql
$ sudo systemctl start postgresql
\end{verbatim}
}

Pentru început, creăm un utilizator nou, căruia îi putem da ce atribuții dorim,
precum și o bază de date pe care utilizatorul respectiv să o poată accesa (sau
administra, în funcție de rolul dat):
{
  \small
\begin{verbatim}
# devenim utilizatorul postgres mai întîi
$ sudo -iu postgres

# creăm utilizatorul (e.g. theUser) cu dialog pas cu pas, pentru a alege rolul
[postgres]$ createuser --interactive

# creăm o bază de date pentru el (e.g. theDatabase)
[postgres]$ createdb -O theUser theDatabase

# dacă theUser nu are rol de creare, putem crea cu postgres pentru el
[postgres]$ createdb -U postgres -O theUser theDatabase
\end{verbatim}
}

\index{subshell-ul \texttt{psql}}
Acum putem porni subshell-ul \texttt{psql} și să ne conectăm la baza de date
creată mai sus:
{
  \small
\begin{verbatim}
$ sudo -iu postgres
[postgres]$ psql -d theDatabase

# cîteva dintre meta-comenzile pentru subshell-ul psql:
=> \help                    # accesează help
=> \c <database>            # conectează-te la baza de date <database>
=> \du                      # afișează utilizatorii și permisiunile
=> \dt                      # afișează tabelele și permisiunile
=> \q                       # închide subshell-ul
=> \?                       # afișează toate meta-comenzile
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\section{Crearea tabelelor}
\index{creare!tabele}

În primă fază, devenim utilizatorul \texttt{postgres} și accesăm baza
de date creată:
\begin{verbatim}
[postgres]$ psql biblioteca
\end{verbatim}

Putem încărca un script \texttt{psql} din fișierul \texttt{tabele.sql}, de
exemplu după ce ne-am asigurat că fișierul \texttt{tabele.sql} are
drepturi corespunzătoare, cu meta-comanda:

\begin{verbatim}
biblioteca# \i /calea/catre/script/tabele.sql
\end{verbatim}

Apoi creăm tabelele corespunzătoare schemei din \S\ref{sec:scheme-rel}
folosind scriptul:

\begin{verbatim}
create table bibliotecar (
	   id_bib bigserial not null primary key,
	   -- bigserial = crește singur
	   nume varchar(20) not null,
	   prenume varchar(20) not null,
	   id_spec varchar(20) not null
)

create table edu (
	   id_edu bigserial not null primary key,
	   nume varchar(20) not null,
	   prenume varchar(20) not null,
	   email varchar(20),
	   newsletter boolean,
	   ab_activ boolean not null,
	   foreign key (id_carte_edu) references carte(id_carte),
	   foreign key (id_rev_edu) references revista(id_rev),
	   foreign key (id_spec_edu) references specializare(id_spec)
)

create table nedu (
	   id_cit bigserial not null primary key,
	   nume varchar(20) not null,
	   prenume varchar(20) not null,
	   email varchar(20),
	   newsletter boolean,
	   ab_activ boolean not null,
   foreign key (id_carte_nedu) references carte(id_carte),
   foreign key (id_spec_nedu) references specializare(id_spec)
)

create table restul (
	   id_pub bigserial not null primary key,
	   email varchar(20),
	   pw varchar(20),
	   wishlist text[],		-- vector de cuvinte
	   newsletter boolean
)

create table carte (
	   id_carte bigserial not null primary key,
	   autor_n varchar(20) not null,
	   autor_p varchar(20) not null,
	   titlu varchar(30) not null,
	   an smallserial,	-- 1 -> 32767
	   stoc smallint,	-- -32768 -> 
   foreign key (id_spec_carte) references specializare(id_spec)
)

create table revista (
	   id_rev bigserial not null primary key,
	   autor_n varchar(20) not null,
	   autor_p varchar(20) not null,
	   titlu varchar(30) not null,
	   numar smallserial,
	   stoc smallint,
   foreign key (id_spec_rev) references specializare(id_spec)
)

create table specializare (
	   id_spec bigserial not null primary key,
	   descriere text
)

create table feedback (
	   id_fb bigserial not null primary key,
	   rating smallserial,
	   continut text,
	   datafb date,
	   foreign key (id_bib_fb) references bibliotecar(id_bib),
	   foreign key (id_cit_fb) references nedu(id_cit),
	   foreign key (id_edu_fb) references edu(id_edu),
	   foreign key (id_spec_fb) references specializare(id_spec),
)

create table bib_spec (
	   foreign key (id_bib_bs) references bibliotecar(id_bib) on delete restrict,
   -- nu se șterg tabelele cu referințe pînă ce toate referințele s-au șters
	   foreign key (id_spec_bs) references specializare(id_spec) on delete restrict,
)

create table bib_cit (
	   foreign key (id_bib_bc) references bibliotecar(id_bib),
	   foreign key (id_cit_bc) references nedu(id_cit)
)

create table pub_carte (
	   foreign key (id_pub_pc) references restul(id_pub),
	   foreign key (id_carte_pc) references carte(id_carte)
)
\end{verbatim}

Am adăugat deja constrîngeri în scriptul de mai sus, dar cheile străine
pot fi definite și separat, ca în exemplul de mai jos:
\index{creare!constrîngeri}
\index{creare!cheie străină}

\begin{verbatim}
-- creăm coloana care va deveni cheie străină:
biblioteca# alter table bib_cit
biblioteca# add column id_bib_bc bigint;
ALTER TABLE
biblioteca# alter table bib_cit
biblioteca# add constraint fk_id_bib_bc foreign key (id_bib_bc) 
biblioteca# references bibliotecar(id_bib);
ALTER TABLE
\end{verbatim}

În felul acesta, legăm coloana \texttt{ib\_bib\_bc} de coloana \texttt{bibliotecar(id\_bib)},
iar constrîngerea o numim \texttt{fk\_id\_bib\_bc}.

După aceea, populăm fiecare dintre tabele cu înregistrări. De exemplu,
putem începe cu tabelul care nu conține referințe, \texttt{specializare}:
\index{populare!tabele}

\begin{verbatim}
biblioteca# insert into specializare values (1, 'matematica'), 
                                            (DEFAULT, 'literatura'),
                                            (DEFAULT, 'politica');
INSERT 0 1
\end{verbatim}

Valoarea \texttt{DEFAULT} continuă automat numărătoarea, deoarece
cîmpul respectiv este \texttt{id\_spec}, declarat cu tipul \texttt{bigserial}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../story"
%%% End:
